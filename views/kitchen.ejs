<!DOCTYPE html>
<html>
<head>
  <title>Kitchen Queue</title>
  <style>
    body { font-family: Arial, sans-serif; margin:0; padding: 0; background:#f5f5f5; }
    h1 { margin:0 0 16px; font-size:1.9em; }

    .kitchen-layout { display:flex; align-items:stretch; min-height:100vh; }
    .sidebar { width:320px; background:#ffffff; padding:20px 18px 32px; box-shadow: 2px 0 8px rgba(0,0,0,0.08); display:flex; flex-direction:column; }
    .board-wrapper { flex:1; padding:20px 24px; }
    .board-columns { display:flex; gap:24px; align-items:flex-start; }
    .column { flex:1; min-width:260px; background:#fff; padding:12px 14px 24px; border-radius:12px; box-shadow:0 2px 6px rgba(0,0,0,0.08); }
    .column-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:14px; }
    .column h2 { margin:0; font-size:1.3em; }

    .order { border:1px solid #d9d9d9; padding:10px 12px 12px; margin-bottom:14px; border-radius:10px; background:#fafafa; cursor:grab; position:relative; }
    .order.dragging { opacity:0.35; border-style:dashed; }
    .order-header { font-weight:600; margin-bottom:6px; font-size:1.05em; }
    .line-item { margin-left: 18px; }
    .options { font-style: italic; color: #555; }
    .meta { font-size: 0.8em; color:#555; margin-bottom:4px; }
    .status-buttons { margin-top:6px; }
    .status-buttons form { display:inline; margin-right:4px; }
    .status-buttons button { cursor:pointer; font-size:0.75rem; padding:4px 8px; border-radius:4px; }

    .dropzone { min-height:60px; transition:background-color .15s ease, border-color .15s ease; }
    .dropzone.drag-over { background:#eef7ff; border:2px dashed #3b82f6; border-radius:8px; padding:8px; }

    /* Sidebar specific */
    .stock-controls { background:#fff; border:1px solid #ddd; padding:14px 16px; border-radius:12px; margin-bottom:22px; }
    .stock-controls .order-header { margin-bottom:10px; }
    .stock-actions { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .stock-actions label { font-size:0.8em; font-weight:600; text-transform:uppercase; color:#444; }
    .stock-actions select, .stock-actions input { padding:4px 6px; font-size:0.85em; }
    .stock-actions button { padding:6px 10px; font-size:0.75em; border-radius:4px; cursor:pointer; }
    /* Stock area scrollable */
    #stock-panel { max-height:62vh; overflow-y:auto; padding-right:4px; }
    #stock-panel::-webkit-scrollbar { width:8px; }
    #stock-panel::-webkit-scrollbar-track { background:#f0f0f0; border-radius:4px; }
    #stock-panel::-webkit-scrollbar-thumb { background:#c7c7c7; border-radius:4px; }
    #stock-panel::-webkit-scrollbar-thumb:hover { background:#a8a8a8; }
    #stock-body { display:grid; gap:12px; grid-template-columns:repeat(auto-fill,minmax(160px,1fr)); }
    .stock-section-header { grid-column:1/-1; font-size:0.85em; font-weight:700; letter-spacing:2px; color:#374151; padding:4px 8px; background:#e5e7eb; border-radius:6px; margin-top:4px; text-transform:uppercase; }
    .stock-mini { background:#fff; border:1px solid #d9d9d9; border-radius:10px; padding:10px 12px; display:flex; flex-direction:column; gap:6px; box-shadow:0 1px 2px rgba(0,0,0,0.06); font-family:'Segoe UI', Arial, sans-serif; }
    .stock-mini.out { border-color:#dc2626; background:#fef2f2; }
    .stock-mini.low { border-color:#d97706; background:#fffbeb; }
    .stock-mini .s-name { font-size:0.78em; font-weight:600; line-height:1.2; letter-spacing:0.4px; color:#111827; }
    .stock-mini .s-serv { font-size:1.45em; font-weight:600; line-height:1; font-variant-numeric:tabular-nums; }
    .stock-mini.out .s-serv { color:#dc2626; }
    .stock-mini.low .s-serv { color:#d97706; }
    .stock-mini:not(.out):not(.low) .s-serv { color:#047857; }
    .stock-mini .s-cat { font-size:0.70em; font-weight:700; color:#374151; letter-spacing:0.5px; text-transform:uppercase; }

    /* Color coding for stock levels on items/options */
    .item-in-stock { color:#059669; font-weight:600; }
    .item-out-of-stock { color:#dc2626; font-weight:600; background-color:#fee; padding:2px 4px; border-radius:3px; }
    .item-low-stock { color:#d97706; font-weight:600; }
  </style>
</head>
<body>
  <div class="kitchen-layout">
    <aside class="sidebar">
      <h1>Kitchen</h1>
      <!-- Line Stock Controls -->
      <div class="stock-controls">
        <div class="order-header">Batch Cook / Line Stock</div>
        <div class="stock-actions">
          <label for="prep-item-select">Item</label>
          <select id="prep-item-select">
            <% if (typeof prepItems !== 'undefined' && prepItems && prepItems.length) { %>
              <% prepItems.forEach(it => { %>
                <option value="<%= it.menu_item_id %>"><%= it.name %></option>
              <% }) %>
            <% } %>
          </select>
          <label for="prep-servings">Servings</label>
          <input id="prep-servings" type="number" min="1" step="1" value="12" style="width:80px;" />
          <button id="cook-batch-btn">Cook</button>
          <button id="discard-stock-btn" type="button" style="background-color:#dc2626; color:#fff; border-color:#dc2626;">Discard</button>
        </div>
        <div id="stock-panel" style="display:block; margin-top:14px;">
          <div class="order-header" style="font-weight:600;">Current Line Stock</div>
          <div id="stock-body"></div>
        </div>
      </div>
      <div style="margin-top:auto; font-size:0.7em; color:#666; line-height:1.4;">
        Drag cards between lanes to update status. Stock coloring applies to queued items.
      </div>
    </aside>
    <main class="board-wrapper">
      <div class="board-columns">

    <!-- QUEUED COLUMN -->
    <div class="column dropzone" data-status="queued">
      <div class="column-header">
        <h2>Queued</h2>
      </div>

      <% if (!queued || queued.length === 0) { %>
        <p>No queued orders.</p>
      <% } else { %>
        <% queued.forEach(order => { %>
          <div class="order" draggable="true" data-order-id="<%= order.orderId %>">
            <div class="order-header">
              Order #<%= order.orderId %> - <%= order.dineOption %>
            </div>
            <div class="meta">
              Placed At (CT): <%= order.placedAtCT %>
            </div>
            <% if (order.notes) { %>
              <div class="meta">Notes: <%= order.notes %></div>
            <% } %>

            <ul>
              <% order.items.forEach(item => { %>
                <li class="line-item">
                  <%= item.qty %> x <%= item.menuItem.name %>
                  <% if (item.options && item.options.length > 0) { %>
                    <span class="options">
                      (Options: <%= item.options.join(", ") %>)
                    </span>
                  <% } %>
                </li>
              <% }) %>
            </ul>

            <div class="status-buttons">
              <!-- move to MAKING (prepping) -->
              <form method="post" action="/kitchen/<%= order.orderId %>/status">
                <input type="hidden" name="status" value="prepping">
                <button type="submit">Start Making</button>
              </form>
              <form method="post" action="/kitchen/<%= order.orderId %>/status">
                <input type="hidden" name="status" value="done">
                <button type="submit">Mark Done</button>
              </form>

              <!-- Cancel order -->
              <form method="post" action="/kitchen/<%= order.orderId %>/cancel" onsubmit="return confirm('Are you sure you want to cancel this order?');">
                <button type="submit" style="background-color: #dc2626; border-color: #dc2626;">Cancel Order</button>
              </form>
            </div>
          </div>
        <% }) %>
      <% } %>
    </div>

    <!-- PREPPING COLUMN -->
    <div class="column dropzone" data-status="prepping">
      <div class="column-header">
        <h2>Prepping</h2>
      </div>

      <% if (!cooking || cooking.length === 0) { %>
        <p>No orders currently making.</p>
      <% } else { %>
        <% cooking.forEach(order => { %>
          <div class="order" draggable="true" data-order-id="<%= order.orderId %>">
            <div class="order-header">
              Order #<%= order.orderId %> - <%= order.dineOption %>
            </div>
            <% if (order.customerName) { %>
              <div class="meta" style="font-size: 1.1em; font-weight: 600; color: #dc2626;">
                Customer: <%= order.customerName %>
              </div>
            <% } %>
            <div class="meta">
              Placed At (CT): <%= order.placedAtCT %>
            </div>
            <% if (order.notes) { %>
              <div class="meta">Notes: <%= order.notes %></div>
            <% } %>

            <ul>
              <% order.items.forEach(item => { %>
                <li class="line-item">
                  <%= item.qty %> x <%= item.menuItem.name %>
                  <% if (item.options && item.options.length > 0) { %>
                    <span class="options">
                      (Options: <%= item.options.join(", ") %>)
                    </span>
                  <% } %>
                </li>
              <% }) %>
            </ul>

            <div class="status-buttons">
              <!-- move back to queue -->
              <form method="post" action="/kitchen/<%= order.orderId %>/status">
                <input type="hidden" name="status" value="queued">
                <button type="submit">Send Back to Queue</button>
              </form>

              <!-- mark done -->
              <form method="post" action="/kitchen/<%= order.orderId %>/status">
                <input type="hidden" name="status" value="done">
                <button type="submit">Mark Done</button>
              </form>

              <!-- Cancel order -->
              <form method="post" action="/kitchen/<%= order.orderId %>/cancel" onsubmit="return confirm('Are you sure you want to cancel this order?');">
                <button type="submit" style="background-color: #dc2626; border-color: #dc2626;">Cancel Order</button>
              </form>
            </div>
          </div>
        <% }) %>
      <% } %>
    </div>

    <!-- DONE COLUMN -->
    <div class="column dropzone" data-status="done">
      <div class="column-header">
        <h2>Done</h2>
        <!-- CLEAR DONE BUTTON -->
        <form method="post" action="/kitchen/clear-done">
          <button type="submit">Clear Done</button>
        </form>
      </div>

      <% if (!done || done.length === 0) { %>
        <p>No recent completed orders.</p>
      <% } else { %>
        <% done.forEach(order => { %>
          <div class="order" draggable="true" data-order-id="<%= order.orderId %>">
            <div class="order-header">
              Order #<%= order.orderId %> - <%= order.dineOption %>
            </div>
            <div class="meta">
              Placed At (CT): <%= order.placedAtCT %>
            </div>
            <% if (order.notes) { %>
              <div class="meta">Notes: <%= order.notes %></div>
            <% } %>

            <ul>
              <% order.items.forEach(item => { %>
                <li class="line-item">
                  <%= item.qty %> x <%= item.menuItem.name %>
                  <% if (item.options && item.options.length > 0) { %>
                    <span class="options">
                      (Options: <%= item.options.join(", ") %>)
                    </span>
                  <% } %>
                </li>
              <% }) %>
            </ul>

            <div class="status-buttons">
              <!-- move back to making -->
              <form method="post" action="/kitchen/<%= order.orderId %>/status">
                <input type="hidden" name="status" value="prepping">
                <button type="submit">Move Back to Making</button>
              </form>

              <!-- Cancel order -->
              <form method="post" action="/kitchen/<%= order.orderId %>/cancel" onsubmit="return confirm('Are you sure you want to cancel this order?');">
                <button type="submit" style="background-color: #dc2626; border-color: #dc2626;">Cancel Order</button>
              </form>
            </div>
          </div>
        <% }) %>
      <% } %>
    </div>

      </div>
    </main>
  </div>
</body>
<!-- Status error modal -->
<div id="status-error-modal" style="position:fixed; inset:0; display:none; background:rgba(0,0,0,0.7); align-items:center; justify-content:center; z-index:9999;">
  <div style="background:#fff; padding:24px; border-radius:12px; max-width:600px; width:90%; box-shadow:0 20px 50px rgba(0,0,0,0.4); border: 3px solid #dc2626;">
    <div style="font-size:1.3em; font-weight:bold; color:#dc2626; margin-bottom:12px; display:flex; align-items:center; gap:8px;">
      <span style="font-size:1.8em;">⚠️</span>
      <span>Cannot Update Status - Missing Stock!</span>
    </div>
    <div id="status-error-text" style="margin:12px 0 20px; font-size:1.1em; line-height:1.6; color:#000; background:#fee2e2; padding:12px; border-radius:6px; border-left:4px solid #dc2626;"></div>
    <div style="display:flex; gap:10px; justify-content:flex-end;">
      <button id="status-error-close" style="padding:10px 24px; font-size:1.1em; background:#dc2626; color:#fff; border:none; border-radius:6px; cursor:pointer; font-weight:600;">Close</button>
    </div>
  </div>
</div>
<script>
  // @ts-nocheck
  (function(){
    const CATEGORY_NAMES = { 3: 'Entree', 4: 'Side' };
    const selectEl = document.getElementById('prep-item-select');
    const servingsEl = document.getElementById('prep-servings');
    const cookBtn = document.getElementById('cook-batch-btn');
    // Removed view toggle: stock always visible
    const discardBtn = document.getElementById('discard-stock-btn');
    const stockPanel = document.getElementById('stock-panel');
    const stockBody = document.getElementById('stock-body');

    // Stock data from server (embed raw JSON to avoid HTML-escaping)
    const stockByMenuItemId = new Map(<%- JSON.stringify(Array.from(stockByMenuItemId || new Map())) %>);
    const nameToMenuItemId = new Map(<%- JSON.stringify(Array.from(nameToMenuItemId || new Map())) %>);

    // Apply color coding to queued items only
    function applyColorCoding() {
      const queuedColumn = document.querySelector('.board-columns .column[data-status="queued"]');
      if (!queuedColumn) return;
      
      const items = queuedColumn.querySelectorAll('.line-item');
      items.forEach(item => {
        // Get just the main text before any nested elements
        const firstTextNode = Array.from(item.childNodes).find(n => n.nodeType === Node.TEXT_NODE);
        if (!firstTextNode) return;
        
        const text = firstTextNode.textContent.trim();
        // Extract quantity and item name
        const itemNameMatch = text.match(/(\d+)\s+x\s+(.+?)$/);
        if (!itemNameMatch) return;
        
        const quantity = parseInt(itemNameMatch[1], 10);
        let itemName = itemNameMatch[2].trim();
        
        // Strip size suffix so lookup matches base menu item
        const sizeMatch = itemName.match(/\((Small|Medium|Large)\)$/);
        if (sizeMatch) {
          itemName = itemName.replace(/\s*\((Small|Medium|Large)\)$/, '');
        }

        const menuItemId = nameToMenuItemId.get(itemName);
        
        if (!menuItemId) return; // Not a prepared item (like Bowl/Plate)
        
        const stock = stockByMenuItemId.get(menuItemId) || 0;
        
        item.classList.remove('item-out-of-stock','item-low-stock','item-in-stock');
        // Check if there's enough stock for the quantity needed
        if (stock < quantity) {
          item.classList.add('item-out-of-stock');
        } else {
          item.classList.add('item-in-stock');
        }
      });

      // Also check options for prepared items in queued column only
      const optSpans = queuedColumn.querySelectorAll('.options');
      optSpans.forEach(optSpan => {
        // Normalize text and extract individual option names
        const text = optSpan.textContent.trim();
        // Remove the "(Options:" prefix even if there's leading whitespace
        const optionsText = text.replace(/\(Options:\s*/, '').replace(/\)$/, '');
        const rawOptions = optionsText.split(',').map(o => o.trim());

        // Rebuild options HTML with per-option chips colored independently
        const parts = [];
        rawOptions.forEach(opt => {
          // Extract quantity if present (e.g., "Beijing Beef x2" or "2 x Beijing Beef")
          let quantity = 1;
          let cleanName = opt;
          
          // Handle "Name x2" format
          const xMatch = opt.match(/^(.*?)\s+x(\d+)$/);
          if (xMatch) {
            cleanName = xMatch[1].trim();
            quantity = parseInt(xMatch[2], 10);
          }

          // Strip size suffix in options as well
          const optSize = cleanName.match(/\((Small|Medium|Large)\)$/);
          if (optSize) {
            cleanName = cleanName.replace(/\s*\((Small|Medium|Large)\)$/, '');
          }
          
          // Remove half-side notation
          cleanName = cleanName.replace(/\s+\(1\/2\)$/, '');
          cleanName = cleanName.replace(/[\s,]+$/, '').replace(/^\s+/, '');
          cleanName = cleanName.replace(/\s{2,}/g, ' ').trim();
          
          const menuItemId = nameToMenuItemId.get(cleanName);
          let cls = '';
          if (menuItemId) {
            const stock = stockByMenuItemId.get(menuItemId) || 0;
            // Check if there's enough stock for the quantity
            cls = stock < quantity ? 'item-out-of-stock' : 'item-in-stock';
          }
          parts.push(`<span class="${cls}">${opt}</span>`);
        });
        optSpan.innerHTML = `(Options: ${parts.join(', ')})`;
      });
    }

    // Run color coding on page load
    applyColorCoding();

    // Live updates via Server-Sent Events (instant), with polling fallback
    let lastQueuedCount = null;
    let sseConnected = false;
    try {
      const evt = new EventSource('/kitchen/events');
      evt.onopen = () => {
        console.log('SSE connected');
        sseConnected = true;
      };
      evt.onerror = (err) => {
        console.warn('SSE error, using polling fallback', err);
        sseConnected = false;
      };
      evt.addEventListener('queued-changed', () => {
        console.log('SSE: queued-changed received, reloading...');
        location.reload();
      });
      evt.addEventListener('stock-updated', (e) => {
        try {
          const payload = JSON.parse(e.data || '{}');
          console.log('SSE: stock-updated', payload);
          if (payload && typeof payload.menu_item_id === 'number') {
            stockByMenuItemId.set(payload.menu_item_id, Number(payload.servings_available) || 0);
            applyColorCoding();
          }
        } catch {}
      });
      evt.addEventListener('stock-refresh', () => {
        console.log('SSE: stock-refresh received');
        refreshStockAndRecolor();
      });
    } catch (e) {
      console.warn('SSE not available', e);
    }
    
    async function refreshStockAndRecolor() {
      try {
        const res = await fetch('/kitchen/stock');
        const data = await res.json();
        if (!data.success) return;
        stockByMenuItemId.clear();
        (data.stock || []).forEach(row => {
          stockByMenuItemId.set(row.menu_item_id, Number(row.servings_available) || 0);
        });
        buildStockBody(data.stock || []);
        applyColorCoding();
      } catch (e) {
        console.warn('stock refresh failed', e);
      }
    }
    
    async function refreshQueuedCount() {
      try {
        const res = await fetch('/kitchen/queued-count');
        const data = await res.json();
        if (data && typeof data.count === 'number') {
          if (lastQueuedCount === null) {
            lastQueuedCount = data.count;
          } else if (data.count !== lastQueuedCount) {
            // New or removed queued orders — auto reload
            location.reload();
          }
        }
      } catch (e) {
        console.warn('queued-count fetch failed', e);
      }
    }

    // Initialize polling (more aggressive check for new orders)
    (async function initPolling() {
      // Wait a moment for SSE to connect
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      try {
        const res = await fetch('/kitchen/queued-count');
        const data = await res.json();
        if (data && typeof data.count === 'number') {
          lastQueuedCount = data.count;
          console.log('Initial queued count:', lastQueuedCount);
        }
      } catch (e) {
        console.warn('initial queued-count failed', e);
      }
      
      // Poll every 2 seconds for queued count changes
      setInterval(() => {
        refreshStockAndRecolor();
        refreshQueuedCount();
      }, 2000);
    })();

    function buildStockBody(rows){
      stockBody.innerHTML='';
      // Sort: category order (3,4,others) then name alphabetically within each group
      const catWeight = (id) => id===3?1:id===4?2:3;
      const sorted = [...rows].sort((a,b) => {
        const ca = catWeight(a.menu_item?.category_id||0);
        const cb = catWeight(b.menu_item?.category_id||0);
        if (ca !== cb) return ca - cb;
        const na = (a.menu_item?.name||'').toLowerCase();
        const nb = (b.menu_item?.name||'').toLowerCase();
        return na.localeCompare(nb);
      });
      let currentGroup = null;
      sorted.forEach(row => {
        const catId = row.menu_item?.category_id;
        let groupLabel = catId === 3 ? 'ENTREES' : (catId === 4 ? 'SIDES' : 'OTHER');
        if (groupLabel !== currentGroup){
          currentGroup = groupLabel;
          const header = document.createElement('div');
            header.textContent = groupLabel;
            header.className = 'stock-section-header';
            stockBody.appendChild(header);
        }
        const name = row.menu_item?.name || ('#'+row.menu_item_id);
        const cat = CATEGORY_NAMES[catId] || '';
        const servings = Number(row.servings_available)||0;
        const card = document.createElement('div');
        let stateCls='';
        if (servings===0) stateCls='out'; else if (servings<5) stateCls='low';
        card.className='stock-mini '+stateCls;
        card.innerHTML = `
          <div class="s-cat">${cat}</div>
          <div class="s-name">${name}</div>
          <div class="s-serv">${servings}</div>`;
        stockBody.appendChild(card);
      });
    }
    async function loadStock(){
      try{
        const res = await fetch('/kitchen/stock');
        const data = await res.json();
        if(!data.success) return;
        buildStockBody(data.stock||[]);
      }catch(e){ console.warn('loadStock error', e); }
    }

    cookBtn?.addEventListener('click', async () => {
      const id = parseInt(selectEl.value, 10);
      const servings = parseInt(servingsEl.value, 10);
      if (!Number.isFinite(id) || !Number.isFinite(servings) || servings <= 0) {
        alert('Please choose an item and a valid servings count');
        return;
      }
      try {
        const res = await fetch(`/kitchen/stock/${id}/cook`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ servings })
        });
        if (!res.ok) {
          let j = null;
          try { j = await res.json(); } catch {}
          if (j && Array.isArray(j.details) && j.details.length) {
            const list = j.details.map(d => `\u2022 ${d.name} — have ${d.have}, need ${d.need}`).join('<br>');
            errText.innerHTML = `<strong>Insufficient inventory:</strong><br>${list}`;
            errModal.style.display = 'flex';
          } else {
            errText.innerHTML = `<strong>Cook failed.</strong> ${j?.error || ''}`;
            errModal.style.display = 'flex';
          }
          return;
        }
        const data = await res.json();
        if (!data.success) throw new Error(data.error || 'Cook failed');
        // Immediately refresh stock and update colors
        await refreshStockAndRecolor();
        alert('Batch cooked successfully');
        if (stockPanel.style.display !== 'none') {
          await loadStock();
        }
      } catch (e) {
        // Try to parse detailed inventory shortage from response body
        try {
          const text = e?.message || '';
          // Attempt to fetch last response body via re-request pattern is unreliable; fallback to modal message
          errText.innerHTML = '<strong>Failed to cook batch.</strong>\nPlease check inventory quantities for this recipe.';
          errModal.style.display = 'flex';
        } catch {
          errText.innerHTML = '<strong>Failed to cook batch.</strong>';
          errModal.style.display = 'flex';
        }
      }
    });

    // Stock always shown; initial load:
    loadStock();

    discardBtn?.addEventListener('click', async () => {
      if (!confirm('Discard all remaining prepared stock?')) return;
      try {
        const res = await fetch('/kitchen/stock/discard', { method: 'POST' });
        const data = await res.json();
        if (!data.success) throw new Error(data.error || 'Discard failed');
        alert('Stock discarded');
        // Immediately refresh stock and update colors
        await refreshStockAndRecolor();
        if (stockPanel.style.display !== 'none') {
          await loadStock();
        }
      } catch (e) {
        console.error('discard error', e);
        alert('Failed to discard stock: ' + (e.message || 'Unknown error'));
      }
    });

    // Intercept status change forms to show popup errors instead of full-page
    const errModal = document.getElementById('status-error-modal');
    const errText = document.getElementById('status-error-text');
    const errClose = document.getElementById('status-error-close');
    errClose.addEventListener('click', () => {
      errModal.style.display = 'none';
    });

    document.querySelectorAll('.status-buttons form[action*="/status"]').forEach((form) => {
      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const fd = new FormData(form);
        const body = new URLSearchParams([...fd.entries()]);
        try {
          const res = await fetch(form.action, {
            method: 'POST',
            headers: { 'Accept': 'text/plain' },
            body
          });
          if (res.ok) {
            window.location.reload();
            return;
          }
          const msg = await res.text();
          // Format the error message for better readability
          let formattedMsg = msg || 'Failed to update status.';
          if (formattedMsg.includes('Insufficient prepared stock:')) {
            formattedMsg = formattedMsg.replace('Insufficient prepared stock:', '<strong>You need to cook:</strong><br>');
            formattedMsg = formattedMsg.replace(/,\s*/g, '<br>\u2022 ');
            formattedMsg = '\u2022 ' + formattedMsg;
          }
          errText.innerHTML = formattedMsg;
          errModal.style.display = 'flex';
        } catch (err) {
          console.error('status update error', err);
          errText.innerHTML = '<strong>Network error.</strong> Please try again.';
          errModal.style.display = 'flex';
        }
      });
    });
  })();
  // ----- Drag & Drop for order cards -----
  (function enableDrag(){
    const zones = document.querySelectorAll('.dropzone');
    let dragOrderId = null;
    document.querySelectorAll('.order[draggable="true"]').forEach(card => {
      card.addEventListener('dragstart', e => {
        dragOrderId = card.getAttribute('data-order-id');
        card.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', dragOrderId);
      });
      card.addEventListener('dragend', () => {
        card.classList.remove('dragging');
        dragOrderId = null;
      });
    });
    zones.forEach(zone => {
      zone.addEventListener('dragover', e => {
        if (!dragOrderId) return;
        e.preventDefault();
        zone.classList.add('drag-over');
        e.dataTransfer.dropEffect = 'move';
      });
      zone.addEventListener('dragleave', () => zone.classList.remove('drag-over'));
      zone.addEventListener('drop', async e => {
        zone.classList.remove('drag-over');
        const status = zone.getAttribute('data-status');
        const orderId = dragOrderId || e.dataTransfer.getData('text/plain');
        if (!orderId || !status) return;
        try {
          const res = await fetch(`/kitchen/${orderId}/status`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams({ status })
          });
          if (!res.ok) {
            const txt = await res.text();
            const errModal = document.getElementById('status-error-modal');
            const errText = document.getElementById('status-error-text');
            errText.innerHTML = txt || 'Failed to move card.';
            errModal.style.display = 'flex';
            return;
          }
          location.reload();
        } catch (err) {
          console.error('Drag move failed', err);
        }
      });
    });
  })();
</script>
</html>
